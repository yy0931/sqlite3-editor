use crate::keywords::{KEYWORDS_UNSUPPORTED_BY_SQLPARSER, START_OF_STATEMENT_KEYWORDS_UNSUPPORTED_BY_SQLPARSER};

#[test]
fn test_start_of_statement_keywords() {
    for keyword in [
        "ALTER",
        "ANALYZE",
        "ATTACH",
        "BEGIN",
        "COMMIT",
        "CREATE",
        "DELETE",
        "DETACH",
        "DROP",
        "END",
        "EXPLAIN",
        "INSERT",
        "PRAGMA",
        "REINDEX",
        "RELEASE",
        "REPLACE",
        "ROLLBACK",
        "SAVEPOINT",
        "SELECT",
        "UPDATE",
        "VACUUM",
        "VALUES",
        "WITH",
    ] {
        assert!(
            sqlparser::keywords::ALL_KEYWORDS.contains(&keyword)
                || START_OF_STATEMENT_KEYWORDS_UNSUPPORTED_BY_SQLPARSER.contains(&keyword),
            "{keyword} is missing",
        );
    }
}

#[test]
fn test_keywords() {
    let missing = "ABORT,ACTION,ADD,AFTER,ALL,ALTER,ALWAYS,ANALYZE,AND,AS,ASC,ATTACH,AUTOINCREMENT,BEFORE,BEGIN,BETWEEN,BY,CASCADE,CASE,CAST,CHECK,COLLATE,COLUMN,COMMIT,CONFLICT,CONSTRAINT,CREATE,CROSS,CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,DATABASE,DEFAULT,DEFERRED,DEFERRABLE,DELETE,DESC,DETACH,DISTINCT,DO,DROP,END,EACH,ELSE,ESCAPE,EXCEPT,EXCLUSIVE,EXCLUDE,EXISTS,EXPLAIN,FAIL,FILTER,FIRST,FOLLOWING,FOR,FOREIGN,FROM,FULL,GENERATED,GLOB,GROUP,GROUPS,HAVING,IF,IGNORE,IMMEDIATE,IN,INDEX,INDEXED,INITIALLY,INNER,INSERT,INSTEAD,INTERSECT,INTO,IS,ISNULL,JOIN,KEY,LAST,LEFT,LIKE,LIMIT,MATCH,MATERIALIZED,NATURAL,NO,NOT,NOTHING,NOTNULL,NULL,NULLS,OF,OFFSET,ON,OR,ORDER,OTHERS,OUTER,OVER,PARTITION,PLAN,PRAGMA,PRECEDING,PRIMARY,QUERY,RAISE,RANGE,RECURSIVE,REFERENCES,REGEXP,REINDEX,RELEASE,RENAME,REPLACE,RESTRICT,RETURNING,RIGHT,ROLLBACK,ROW,ROWS,SAVEPOINT,SELECT,SET,TABLE,TEMP,TEMPORARY,THEN,TIES,TO,TRANSACTION,TRIGGER,UNBOUNDED,UNION,UNIQUE,UPDATE,USING,VACUUM,VALUES,VIEW,VIRTUAL,WHEN,WHERE,WINDOW,WITH,WITHOUT".split(",")
        .into_iter()
        .filter(|&keyword| !(sqlparser::keywords::ALL_KEYWORDS.contains(&keyword) || KEYWORDS_UNSUPPORTED_BY_SQLPARSER.contains(keyword)))
        .collect::<Vec<_>>();

    assert!(missing.is_empty(), "{missing:?} is missing.");
}

#[test]
fn test_unsupported_keywords() {
    for keyword in KEYWORDS_UNSUPPORTED_BY_SQLPARSER.iter() {
        assert!(
            !sqlparser::keywords::ALL_KEYWORDS.contains(&keyword),
            "{keyword:?} exists in sqlparser::keywords."
        );
    }
}
